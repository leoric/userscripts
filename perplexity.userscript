// ==UserScript==
// @name         Improve Perplexity (Enhanced) - Stable Title Capture
// @namespace    https://www.perplexity.ai
// @version      3.8
// @description  Capture a stable <title> once (after site JS finishes), then replace header text with a Google link using that frozen value.
// @author       leoric
// @match        https://*.perplexity.ai/*
// @grant        none
// @run-at       document-idle
// @icon         https://www.perplexity.ai/favicon.ico
// ==/UserScript==

(function () {
  'use strict';
  console.log('[Violentmonkey] Script started...');

  // Where to inject the link:
  const targetElementsSelector = 'h1';

  // Titles we want to ignore/reject:
  const placeholderText = 'Ask anything…';
  const rejectRegex = /perplexity/i; // reject any title containing "Perplexity" (early default)

  // How long the title must remain unchanged to be considered "stable":
  const STABLE_MS = 800;
  const TIMEOUT_MS = 15000;

  function enableScroll() {
    document.body.style.overflow = 'auto';
    document.documentElement.style.overflow = 'auto';
    console.log('[Violentmonkey] Scroll enabled on the page.');
  }

  function noRegister() {
    document.querySelectorAll('div.text-align-center.relative.truncate.leading-loose').forEach(button => {
      if (button.innerHTML.trim() === 'Close') {
        button.click();
      }
    });
  }

  function cleanTitle(t) {
    if (!t) return '';
    // strip placeholder, trim
    t = t.replace(placeholderText, '').trim();
    // optional: strip site suffixes; uncomment if needed
    // t = t.replace(/\s*[-–—]\s*Perplexity(?: AI)?$/i, '').trim();
    return t;
  }

  function isAcceptableTitle(t) {
    return Boolean(t) && t.length > 1 && !rejectRegex.test(t) && t !== placeholderText;
  }

  function createGoogleLink(text) {
    const a = document.createElement('a');
    a.href = 'https://www.google.com/search?q=' + encodeURIComponent(text);
    a.textContent = text;
    a.style.textDecoration = 'underline';
    a.target = '_blank';
    a.rel = 'noopener noreferrer';
    return a;
  }

  function injectLinksOnce(capturedTitle) {
    const nodes = document.querySelectorAll(targetElementsSelector);
    if (!nodes.length) return false;

    let changed = 0;
    nodes.forEach(node => {
      if (node.querySelector('a')) return; // already injected
      node.replaceChildren(createGoogleLink(capturedTitle));
      changed++;
    });

    if (changed) {
      console.log('[Violentmonkey] Injected links into', changed, 'node(s). Using title =', capturedTitle);
    }
    return Array.from(nodes).every(n => n.querySelector('a'));
  }

  function waitForTargetsAndInject(capturedTitle) {
    enableScroll();
    noRegister();

    const start = Date.now();
    const interval = setInterval(() => {
      const done = injectLinksOnce(capturedTitle);
      if (done || Date.now() - start > 10000) {
        clearInterval(interval);
        console.log('[Violentmonkey] Injection complete (or timed out).');
      }
    }, 250);
  }

  async function waitForStableTitle() {
    const titleEl = document.head.querySelector('title') || (() => {
      const el = document.createElement('title');
      document.head.appendChild(el);
      return el;
    })();

    let last = cleanTitle(document.title.trim());
    let lastChange = performance.now();
    let best = last;

    const onMut = () => {
      const t = cleanTitle(document.title.trim());
      if (t !== last) {
        last = t;
        lastChange = performance.now();
        best = t;
        // debug
        // console.log('[Violentmonkey] Title mutation observed:', t);
      }
    };

    const mo = new MutationObserver(onMut);
    mo.observe(titleEl, { childList: true, characterData: true, subtree: true });

    // Also poll, because some frameworks set document.title without touching <title> node
    const poll = setInterval(onMut, 100);

    const start = performance.now();
    while (true) {
      await new Promise(r => setTimeout(r, 100));
      const stableFor = performance.now() - lastChange;

      if (isAcceptableTitle(last) && stableFor >= STABLE_MS) {
        clearInterval(poll);
        mo.disconnect();
        console.log('[Violentmonkey] Stable title captured:', last, `(stable ${Math.round(stableFor)}ms)`);
        return last;
      }

      if (performance.now() - start > TIMEOUT_MS) {
        clearInterval(poll);
        mo.disconnect();
        const fallback = isAcceptableTitle(best) ? best : cleanTitle(document.title.trim());
        console.warn('[Violentmonkey] Title capture timed out. Using fallback:', fallback);
        return fallback || 'Search';
      }
    }
  }

  (async function main() {
    const captured = await waitForStableTitle();
    // Do not read document.title again after this point.
    waitForTargetsAndInject(captured);
  })();
})();
