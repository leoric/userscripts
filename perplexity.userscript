// ==UserScript==
// @name         Improve Perplexity (Enhanced) - Stable Title + Lexical Debug
// @namespace    https://www.perplexity.ai
// @version      3.9
// @description  Capture stable <title> once, inject into headers, and set the Lexical-powered #ask-input with rich debug logs.
// @author       leoric
// @match        https://*.perplexity.ai/*
// @grant        none
// @run-at       document-idle
// @icon         https://www.perplexity.ai/favicon.ico
// ==/UserScript==

(function () {
  'use strict';
  console.log('[Violentmonkey] Script started...');

  // Where to inject the link:
  const targetElementsSelector = 'h1';

  // Ignore placeholder / early titles:
  const placeholderText = 'Ask anything…';
  const rejectRegex = /perplexity/i;

  const STABLE_MS = 800;
  const TITLE_TIMEOUT_MS = 15000;

  function enableScroll() {
    document.body.style.overflow = 'auto';
    document.documentElement.style.overflow = 'auto';
    console.log('[Violentmonkey] Scroll enabled on the page.');
  }

  function noRegister() {
    document.querySelectorAll('div.text-align-center.relative.truncate.leading-loose').forEach(button => {
      if (button.innerHTML.trim() === 'Close') {
        button.click();
      }
    });
  }

  function cleanTitle(t) {
    if (!t) return '';
    t = t.replace(placeholderText, '').trim();
    // Optional: strip site suffix
    // t = t.replace(/\s*[-–—]\s*Perplexity(?: AI)?$/i, '').trim();
    return t;
  }

  function isAcceptableTitle(t) {
    return Boolean(t) && t.length > 1 && !rejectRegex.test(t) && t !== placeholderText;
  }

  function createGoogleLink(text) {
    const a = document.createElement('a');
    a.href = 'https://www.google.com/search?q=' + encodeURIComponent(text);
    a.textContent = text;
    a.style.textDecoration = 'underline';
    a.target = '_blank';
    a.rel = 'noopener noreferrer';
    return a;
  }

  function injectLinksOnce(capturedTitle) {
    const nodes = document.querySelectorAll(targetElementsSelector);
    if (!nodes.length) return false;

    let changed = 0;
    nodes.forEach(node => {
      if (node.querySelector('a')) return;
      node.replaceChildren(createGoogleLink(capturedTitle));
      changed++;
    });
    if (changed) {
      console.log('[Violentmonkey] Injected links into', changed, 'node(s). Using title =', capturedTitle);
    }
    return Array.from(nodes).every(n => n.querySelector('a'));
  }

  function waitForTargetsAndInject(capturedTitle) {
    enableScroll();
    noRegister();

    const start = Date.now();
    const interval = setInterval(() => {
      const done = injectLinksOnce(capturedTitle);
      if (done || Date.now() - start > 10000) {
        clearInterval(interval);
        console.log('[Violentmonkey] Header injection complete (or timed out).');
      }
    }, 250);
  }

  async function waitForStableTitle() {
    const titleEl = document.head.querySelector('title') || (() => {
      const el = document.createElement('title');
      document.head.appendChild(el);
      return el;
    })();

    let last = cleanTitle(document.title.trim());
    let lastChange = performance.now();
    let best = last;

    const onMut = () => {
      const t = cleanTitle(document.title.trim());
      if (t !== last) {
        last = t;
        lastChange = performance.now();
        best = t;
        console.log('[Violentmonkey] Title mutation:', JSON.stringify(t));
      }
    };

    const mo = new MutationObserver(onMut);
    mo.observe(titleEl, { childList: true, characterData: true, subtree: true });

    const poll = setInterval(onMut, 100);

    const start = performance.now();
    while (true) {
      await new Promise(r => setTimeout(r, 100));
      const stableFor = performance.now() - lastChange;

      if (isAcceptableTitle(last) && stableFor >= STABLE_MS) {
        clearInterval(poll);
        mo.disconnect();
        console.log('[Violentmonkey] Stable title captured:', JSON.stringify(last), `(stable ${Math.round(stableFor)}ms)`);
        return last;
      }

      if (performance.now() - start > TITLE_TIMEOUT_MS) {
        clearInterval(poll);
        mo.disconnect();
        const fallback = isAcceptableTitle(best) ? best : cleanTitle(document.title.trim());
        console.warn('[Violentmonkey] Title capture timed out. Using fallback:', JSON.stringify(fallback));
        return fallback || 'Search';
      }
    }
  }

  // --------- Lexical Helpers with DEBUG ---------

  function waitForFollowUp(ms = 10000) {
    return new Promise(resolve => {
      const t0 = Date.now();
      const timer = setInterval(() => {
        const el = document.querySelector('#ask-input[contenteditable="true"][data-lexical-editor="true"]');
        if (el) {
          clearInterval(timer);
          resolve(el);
        } else if (Date.now() - t0 > ms) {
          clearInterval(timer);
          resolve(null);
        }
      }, 100);
    });
  }

  function logLexicalTree(editor, label = 'BEFORE') {
    try {
      editor.getEditorState().read(() => {
        const L = (window.lexical || {});
        const $getRoot = L.$getRoot;
        if (!$getRoot) {
          console.warn('[Violentmonkey] logLexicalTree: window.lexical not exposed; cannot traverse nodes.');
          return;
        }
        const root = $getRoot();
        const kids = root.getChildren();
        const summary = kids.map((k, i) => {
          const type = k.getType ? k.getType() : typeof k;
          let text = '';
          try {
            if (type === 'paragraph') {
              const spans = k.getChildren();
              text = spans.map(s => (s.getTextContent ? s.getTextContent() : '')).join('');
            } else {
              text = k.getTextContent ? k.getTextContent() : '';
            }
          } catch (e) {}
          return { idx: i, type, text };
        });
        console.log(`[Violentmonkey] Lexical tree ${label}:`, { childCount: kids.length, summary });
      });
    } catch (e) {
      console.warn('[Violentmonkey] logLexicalTree error:', e);
    }
  }

  async function setFollowUp(value) {
    const inputDiv = await waitForFollowUp();
    if (!inputDiv) {
      console.warn('[Violentmonkey] #ask-input not found within timeout.');
      return;
    }

    console.log('[Violentmonkey] #ask-input found. data-lexical-editor =', inputDiv.getAttribute('data-lexical-editor'));

    // Lexical editor instance is usually here:
    const editor = inputDiv.__lexicalEditor;
    console.log('[Violentmonkey] __lexicalEditor present:', Boolean(editor));

    const L = (window.lexical || {});
    const haveLexicalAPI = !!(L.$getRoot && L.$createParagraphNode && L.$createTextNode);
    console.log('[Violentmonkey] window.lexical available:', Boolean(window.lexical),
                'have $getRoot/$createParagraphNode/$createTextNode:', haveLexicalAPI);

    if (editor && haveLexicalAPI) {
      // Proper Lexical path with detailed logs
      try {
        logLexicalTree(editor, 'BEFORE');

        editor.update(() => {
          const root = L.$getRoot();
          console.log('[Violentmonkey] $getRoot() =>', root ? ('key=' + root.getKey()) : root);

          // Clear content
          root.clear();

          // Build new paragraph + text
          const p = L.$createParagraphNode();
          const t = L.$createTextNode(value);
          p.append(t);
          root.append(p);

          // Move selection to end (optional)
          try {
            const sel = L.$getSelection ? L.$getSelection() : null;
            if (sel && sel.setTextNodeRange) {
              sel.setTextNodeRange(t, value.length, t, value.length);
            }
          } catch (e) {
            // selection is optional; ignore if not available
          }
        });

        // Read back and log AFTER state
        setTimeout(() => logLexicalTree(editor, 'AFTER'), 0);

        console.log('[Violentmonkey] Set #ask-input via Lexical API to:', value);
        return;
      } catch (e) {
        console.warn('[Violentmonkey] Lexical API update failed, will try fallback. Error:', e);
      }
    } else {
      // Extra insight if the editor exists but window.lexical is not exposed
      if (editor && !haveLexicalAPI) {
        try {
          // Try to introspect internal nodeMap root for debugging only
          const nodeMap = editor._editorState && editor._editorState._nodeMap;
          const rootNode = nodeMap && nodeMap.get('root');
          console.log('[Violentmonkey] Internal nodeMap root (debug):', rootNode);
        } catch (e) {}
      }
    }

    // Fallback: simulate user input (works with most Lexical setups)
    try {
      inputDiv.focus();

      // Select all existing content
      const sel = window.getSelection();
      sel.removeAllRanges();
      const r = document.createRange();
      r.selectNodeContents(inputDiv);
      sel.addRange(r);

      // Replace with the target text
      const ok = document.execCommand('insertText', false, value);
      console.log('[Violentmonkey] Fallback execCommand insertText success:', ok);

      // Place caret at end just in case
      sel.removeAllRanges();
      const r2 = document.createRange();
      r2.selectNodeContents(inputDiv);
      r2.collapse(false);
      sel.addRange(r2);

      console.log('[Violentmonkey] Set #ask-input via fallback to:', value);
    } catch (e) {
      console.error('[Violentmonkey] Fallback input failed:', e);
    }
  }

  // ----------------- MAIN -----------------
  (async function main() {
    const captured = await waitForStableTitle();
    // Do not read document.title again after this point.
    waitForTargetsAndInject(captured);

    // Now set #ask-input with the captured text, with full debug:
    await setFollowUp(captured);
  })();
})();
